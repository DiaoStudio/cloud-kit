# 缓存端模式（Cache-Aside Pattern）

![Data Management](https://i-msdn.sec.s-msft.com/dynimg/IC709483.png)![Performance & Scalability](https://i-msdn.sec.s-msft.com/dynimg/IC709484.png)[![Design Patterns](https://i-msdn.sec.s-msft.com/dynimg/IC709485.png)](https://msdn.microsoft.com/en-us/library/dn600223.aspx)  [![Show All](https://i-msdn.sec.s-msft.com/dynimg/IC709871.png)](../)

简单来说就是将数据从持久化存储中加载到cache中。这个模式可以提升系统性能，并且保证cache和底层存储中数据的一致性。PS:下文会用“存储空间”来表示data store，在实际的工程中可以代表数据库、文件等持久化到硬盘的存储容器。

## 现状及难题

传统的应用程序中经常使用cache来优化那种需要频繁、重复地访问存储中数据的情景。但一般情况下很难使cache中的数据与底层存储中的数据达到完全一致性。程序中必须实现一种策略，不仅能够使得cache中的数据尽可能与存储器中的数据同步，同时当cache中的数据变得陈旧（不同步）时能够感知并进行正确的处理。

## 解决方案

很多商业的缓存系统提供了穿透读（read-through）和穿透写（write-through）/write-behind（http://www.infoq.com/cn/articles/write-behind-caching/  这篇文章把write-behind讲得挺透彻的）。在这些系统中，应用程序都通过缓存来检索/读取数据，如果缓存中不存在所需要的数据，那么缓存会以一种对应用程序透明的方式来从存储器中取出数据并添加到缓存中。此外，任何对数据的改动都会在缓存中进行，而缓存会自动地将这些改动写到存储器中。

而对于那些不提供这些功能的cache来说，应用程序必须自己来维护缓存中的数据：

应用程序可以通过实现read-through策略来达到相同的效果，这种策略在需要将数据加载到cache中时会非常有效，Figure 1 总结了一下这个过程的步骤：

![Figure 1 - Using the Cache-Aside pattern to store data in the cache](../files/en/1_Figure_1.png)

1.	检查所要读取的数据是否在缓存中。
2.	如果数据不在缓存中，就直接从存储空间中读取数据，将数据返回给应用程序。
3.	将这份数据也同时保存到缓存中。

如果应用程序需要写入/更新数据，那么可以通过以下步骤来实现write-through：

1.	先修改存储空间中的数据。
2.	如果缓存中有对应数据，那么将该数据置为无效（抛弃）。如果之后用到这部分数据，那么缓存会再次从存储空间中加载数据。

## 问题及注意事项

当使用这一模式时需要注意以下几点：

*	缓存数据的生命周期。很多缓存实现了一种数据失效规则，即当数据在一个指定的时间内没有被使用时，就会被从缓存中移除。在实际使用中这种规则必须要根据应用程序访问数据的特性来好好设计，以使得缓存在系统中发挥最大作用。比如说不能将这个失效时间设置得过短，否则会导致应用程序频繁地访问存储空间，从存储空间加载数据并将数据插入到缓存。相应的也不应该将失效时间设置得过长，否则会导致缓存中保留许多非热点数据，造成存储空间的浪费。缓存中存放不变的并且会被频繁使用的数据时会发挥其最大作用。
*	缓存数据的清除（抛弃）。绝大多数缓存容量相比存储空间来说要小得多，所以缓存中只能存放相对来说极为有限的数据量，于是在必要的时候，缓存会对数据做清除动作。绝大多数缓存实现了least-recently-used策略来选择那些需要被清除的数据（即最近一段时间用的最少的数据会被清理出去），但这通常来说也是可以定制化的，通过配置缓存的全局数据超时时间等配置项，以及指定单条数据的超时时间，可以使缓存达到最高效率。此外，使用一个全局的缓存数据清除策略有的时候也并不是很合适，比如说有些数据重载代价非常高，那么相对一些使用频率相对来说较高，但重载开销较低的数据来说，这种数据更有必要保存在缓存里。
*	启动缓存。在很多解决方案中，应用程序会将加载应用可能会用到的数据作为启动过程的一部分。Cache-Aside模式在这些初始化数据到期或者被废弃时依然很有效。
*	数据一致性。实现这一模式并不保证缓存中的数据和存储空间中的数据能实现一致性。存储空间中的数据很有可能在任意时间被其他进程所修改，此时在缓存中的这份数据不会做同步，除非之后能有操作使得这部分数据从存储空间中重新加载。如果系统频繁地在不同存储空间之间同步数据，那么这一问题会格外严重。
*	本地缓存。对于一个应用程序来说，缓存可以是在本地或者直接基于内存来实现的（原文中着重说明这点是因为在集群中存在利用分布式缓存（即非本地性缓存）或系统采用多层次分层存储（内存-SSD-硬盘），这里所指本地缓存应该指的仅仅是应用程序内部的缓存，比如说在同一个JVM内，并不包括不同进程但在同一物理节点的情况），这种情景下对于频繁读的业务来说，Cache-Aside模式能达到最好的效果。然而，本地内存是私有的，不同的应用程序实例（进程）都保有各自私有的缓存，这很容易造成数据的不一致，所以这种情况下需要将数据的失效时间设短，从而提高从存储空间中同步数据的频率。对于这种情况可以参考一下分布式缓存的实现原理。

## 何时能用到这个模式
这种模式非常适合于：

*	缓存本身不提供本地的穿透读和穿透写操作。
*	对资源的需求不可预估。这个模式使得应用能够在需要时加载数据，并且这个模式不需要应用提前预知可能会用到的数据。

这种模式不适用于：

*	缓存数据是静态数据。如果缓存空间足够存放缓存数据，那么在应用程序初始化时就能把全部数据加载到cache里，并且把数据的失效时间设置成无限长。
*	在一个we应用中用于缓存session状态。